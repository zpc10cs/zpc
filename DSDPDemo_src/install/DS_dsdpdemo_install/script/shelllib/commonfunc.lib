#!/usr/bin/ksh

################################################################################
# Name       : commonfunc.lib
# Describe   : common function shell library for developers.
# Date       : 2008-11-20
# Functions  :
#              update_cfg_value        update properties file.
#              read_xml_tag            read node value of xml.
#              update_xml_tag          update node value of xml.
#              read_xml_tag_spec       read special node value of xml.
#              update_xml_tag_spec     update special node value of xml.
#              port_is_available       verify port whether it is available.
#              get_free_ports          get specified number of free ports.
#              is_integer2             check a string whether it is an positive integer or not.
#              set_progress_range      set global progress range of a component.
#              install_progress        output install progress in a component.
##             env_init_cmd            generate a command list to initialize
#                                      component shell environment.
#              run_vcs_cmd             run vcs command.
#              exec_cmd                execute special command, and store stdout/stderr.
#              get_nic_name            get localhost ip binding NIC name.
#              get_net_mask            get localhost net mask.
#              rpm_install             install rpm package.
#              writeLog                write log to terminal.
#              run_sql                 execute sql script to specify db server
#              db_cut_version_noneed_update
#              app_cut_version_noneed_update
#              backup_files_from_cfg
#              execute_custom_update_script
#              execute_custom_rollback_script
################################################################################

################################################################################
# global variables declare
################################################################################
# global variables for command execute, used by function: exec_cmd
ERR_CODE=0
ERR_MSG=""

################################################################################
# function: update_cfg_value
# description:
#     update value in config file like properties file.
# parameters:
#            cfg_file_name  config file name.
#            key            which key you will update.
#            value          value.
# output:
#            null
# return:
#            0 succeed
#            1 fail
################################################################################
function update_cfg_value
{
	typeset cfg_file="$1"
	typeset key_name="$2"
	typeset value="$3"
	
	if [ ! -r ${cfg_file} ]; then
		touch ${cfg_file} 2>/dev/null
		if [ $? -ne 0 ]; then
			return 1
		fi
	fi
	if [ ! -w ${cfg_file} ]; then
		return 1
	fi
	
	typeset mc=`grep -c "^[ 	]*${key_name}[ 	]*=" ${cfg_file}`
	
	if [ ${mc} -eq 0 ]; then
		echo "${key_name}=${value}" >> ${cfg_file} 2>/dev/null
		if [ $? -ne 0 ]; then
			return 1
		fi
	elif [ ${mc} -eq 1 ]; then
		typeset old_line=`grep "^[ 	]*${key_name}[ 	]*=" ${cfg_file}`
		typeset new_line="${key_name}=${value}"
		sed "s#^${old_line}#${new_line}#g" ${cfg_file} > /tmp/proc_$$_update_cfg_value.tmp 2>/dev/null
		if [ $? -ne 0 ]; then
			rm -f "/tmp/proc_$$_update_cfg_value.tmp"
			return 1
		fi
		mv -f /tmp/proc_$$_update_cfg_value.tmp ${cfg_file} 2>/dev/null
		if [ $? -ne 0 ]; then
			rm -f "/tmp/proc_$$_update_cfg_value.tmp"
			return 1
		fi
	else
		# match lines than 1, properties file format error
		return 1
	fi
	
	return 0
}

################################################################################
# name    : read_xml_tag
# describe: read_xml_tag <filename> <node>
# input   : <filename> <node>
# output  : value of this tag
# rerurn  : 0:success
#           1:failed
################################################################################
function read_xml_tag
{
    #check the number of the parameter
    if [ $# -ne 2 ];then
       install_log DEBUG LIB "Failed to read configuration.The parameter number is error."
       return 1
    fi
    
    typeset source_file=$1
    typeset node=$2
    
	typeset read_xml="perl -I${IDEPLOY_PKG_PATH}/tools ${IDEPLOY_PKG_PATH}/script/read_xml.pl"
    
	RETURN[0]=""
	RETURN[0]=`${read_xml} ${source_file} ${node}` 2>/dev/null
    if [ $? -ne 0 ] ; then 
       install_log DEBUG LIB "Failed to read configuration. The filename is $1;The path of xml tag is $2."
       return 1
    fi
    
	return 0
}

################################################################################
# name    : update_xml_tag
# describe: update_xml_tag <filename> <node> <value>
# input   : <filename> <node> <value>
# output  : null
# rerurn  : 0:success
#           1:failed
################################################################################
function update_xml_tag
{
    #check the number of the parameter
    if [ $# -ne 3 ];then
       install_log DEBUG LIB "Failed to modify configuration.The parameter number is error."
       return 1
    fi
    
    typeset update_file=$1
    typeset node=$2
    typeset value=$3    
    
    typeset write_xml="perl -I${IDEPLOY_PKG_PATH}/tools ${IDEPLOY_PKG_PATH}/script/write_xml.pl"
    
    ${write_xml} ${update_file} ${node} ${value} >/dev/null 2>/dev/null
    if [ $? -ne 0 ] ; then 
       install_log DEBUG LIB "Failed to update configuration. The filename is $1;The path of xml tag is $2; the new value is $3 ."
       return 1
    fi
    
	return 0
}

################################################################################
# name    : read_xml_tag_spec
# describe: read_xml_tag_spec <filename> <nodetree> [<keystring>|<attrname> <keyattrstring>]
# input   : <filename> <nodetree> [<keystring>|<attrname> <keyattrstring>]
# output  : value of tag or value of the attribute
# rerurn  : 0:success
#           1:failed
################################################################################
function read_xml_tag_spec
{
    #check the number of the parameter
    if [ $# -ne 3 -a $# -ne 4 ];then
       install_log DEBUG LIB "Failed to read configuration.The parameter number is error."
       return 1
    fi
    
    typeset source_file=$1
    typeset node=$2
	typeset read_spec_xml="perl -I${IDEPLOY_PKG_PATH}/tools ${IDEPLOY_PKG_PATH}/script/read_spec_xml.pl"
	RETURN[0]=""
	
	if [ $# -eq 3 ]; then
		typeset keystring=$3
		RETURN[0]=`${read_spec_xml} ${source_file} ${node} ${keystring}` 2>/dev/null
    	if [ $? -ne 0 ] ; then 
       		install_log DEBUG LIB "Failed to read configuration. The filename is $1;The path of xml tag is $2;The keystring is $3."
       		return 1
    	fi
	else
		typeset attrname=$3
		typeset keyattrstring=$4
		RETURN[0]=`${read_spec_xml} ${source_file} ${node} ${attrname} ${keyattrstring}` 2>/dev/null
    	if [ $? -ne 0 ] ; then 
       		install_log DEBUG LIB "Failed to read configuration. The filename is $1;The path of xml tag is $2;The attrname is $3; The keyattrstring is $4."
       		return 1
    	fi
	fi
    
	return 0
}

################################################################################
# name    : update_xml_tag_spec
# describe: update_xml_tag_spec <filename> <nodetree> [<keystring>|<attrname> <keyattrstring>] <value>
# input   : <filename> <nodetree> [<keystring>|<attrname> <keyattrstring>] <value>
# output  : null
# rerurn  : 0:success
#           1:failed
################################################################################
function update_xml_tag_spec
{
    #check the number of the parameter
    if [ $# -ne 4 -a $# -ne 5 ];then
       install_log DEBUG LIB "Failed to modify configuration.The parameter number is error."
       return 1
    fi
    
    typeset update_file=$1
    typeset node=$2
    typeset write_spec_xml="perl -I${IDEPLOY_PKG_PATH}/tools ${IDEPLOY_PKG_PATH}/script/write_spec_xml.pl"

	if [ $# -eq 4 ]; then    
    	typeset keystring=$3
    	typeset value=$4
    	${write_spec_xml} ${update_file} ${node} ${keystring} ${value} >/dev/null 2>/dev/null
    	if [ $? -ne 0 ] ; then 
    	   install_log DEBUG LIB "Failed to update configuration. The filename is $1;The path of xml tag is $2; the keystring is $3; the new value is $4 ."
    	   return 1
    	fi
    else
    	typeset attrname=$3
    	typeset keyattrstring=$4
    	typeset value=$5
    	${write_spec_xml} ${update_file} ${node} ${attrname} ${keyattrstring} ${value} >/dev/null 2>/dev/null
    	if [ $? -ne 0 ] ; then 
    	   install_log DEBUG LIB "Failed to update configuration. The filename is $1;The path of xml tag is $2; the attrname is $3; the keyattrstring is $4; the new value is $5 ."
    	   return 1
    	fi
    fi
    
	return 0
}

################################################################################
# name    : port_is_available
# describe: check the port which will be used is available or not.
# parameter list: 
#           para1:port
# output  : 0:success
#           1:failed. The port is exit.
################################################################################
function port_is_available
{
    typeset port=$1
	is_integer2 ${port}
	if [ $? -ne 0 ]; then
		install_log DEBUG "COMMONLIB" "Parameters error, need a port."
		return 1
	fi
	
    inuse=`netstat -an | awk '{ print $4; }' | awk -F: '{ if (NF > 1 && $NF ~ /^[0-9]+$/) { print $NF; } }' | grep -w "${port}"`
    if [ "X${inuse}" != "X" ]; then
        return 1
    fi

    return 0
}

################################################################################
# name    : get_free_ports
# describe: get free ports not used in system and not used in current install
#           task. 
# parameter list: 
#           num                    ports number, optional, default 1
# output  :
#           RETURN[0]...RETURN[num-1]
# return  : 0:success
#           1:failed
################################################################################
function get_free_ports
{
	if [ $# -gt 1 ]; then
		install_log DEBUG "COMMONLIB" "Parameters count error, need: [num]."
		return 1
	fi
	
	RETURN[0]=""
	
	# verify parameters
	typeset port_num="1"
	if [ $# -eq 1 ]; then
		port_num="$1"
		is_integer2 "${port_num}"
		if [ $? -ne 0 ]; then
			install_log DEBUG "COMMONLIB" "Parameters error, need: [num]."
			return 1
		fi
	else
		port_num="1"
	fi
	
	############################################################################
	# resolve simultaneity error in logical dualHost.
	get_local_ne_list
	if [ $? -ne 0 ]; then
		install_log DEBUG COMMONLIB "Getting local ne list failed."
	fi
	typeset first_ne="${RETURN[0]}"
	read_value "_selectedNETypeList"
    if [ $? -ne 0 ];then
        install_log DEBUG COMMONLIB "Getting _selectedNETypeList failed"
        return 1 
    fi
	#get_ne_index_in_localmachine "${first_ne}"
	#if [ $? -ne 0 ]; then
	#	install_log DEBUG COMMONLIB "Getting index of ne: ${first_ne} in physical machine failed."
	#	return 1
	#fi
    typeset ne_list="${RETURN[0]}"
    
	typeset ne_idx=0
    ne_idx=$(echo ${ne_list} | awk -F, -vne_name=${first_ne} '{ for (i = 1; i <= NF; i++) if ($i == ne_name) print i}')
	
	# get max port number last check, default 10001
	typeset base_port=10000
	typeset last_max_port=$(echo 'x' | awk -vbase_port=${base_port} -vne_idx=${ne_idx} '{ print base_port + ne_idx*1000; }')
	############################################################################
	typeset port_status_file="${TMP}/port.list.status"
	typeset port_list_file="${TMP}/ports.list"
	if [ -f "${port_status_file}" ]; then
		last_max_port_tmp="`cat ${port_status_file}`"
		if [ "X${last_max_port_tmp}" != "X" ]; then
			last_max_port="${last_max_port_tmp}"
		fi
		
		is_integer2 "${last_max_port}"
		if [ $? -ne 0 ]; then
			install_log DEBUG "COMMONLIB" "The status file: ${port_status_file} is broken."
			return 1
		fi
	else
		touch "${port_status_file}"
		chmod 666 "${port_status_file}"
	fi
	
	# ports list used in system now, get one time and cached it
	typeset ports_list="`netstat -an | awk '{ print $4; }' | awk -F: '{ if (NF > 1 && $NF ~ /^[0-9]+$/) { print $NF; } }' | sort -n -u`"
	
	# verify whether port is available
	typeset idx=0
	typeset in_use=""
	while [ ${idx} -lt ${port_num} ]
	do
		while [ true ]
		do
			# circle the port number if exceed 65535
			if [ ${last_max_port} -gt 65535 ]; then
				last_max_port=${base_port}
			fi
		
			in_use=`grep -w "${last_max_port}" "${port_list_file}"`
			if [ "X${in_use}" = "X" ]; then
				typeset in_use=`echo "${ports_list}" | grep -w "${last_max_port}"`
				if [ "X${in_use}" = "X" ]; then
					RETURN[${idx}]="${last_max_port}"
					echo "${last_max_port}" >> "${port_list_file}"
					((last_max_port=last_max_port+1))
					break
				fi
			fi
			
			((last_max_port=last_max_port+1))
		done
		
		((idx=idx+1))
	done
	
	# write last_max_port to status file: port.list.status
	echo "${last_max_port}" > "${port_status_file}"
	
	return 0
}

################################################################################
# name    : is_integer2
# describe: check a string whether it is an positive integer or not.
# parameter list: 
#           str         string to check.
# output  :
#           RETURN[0]...RETURN[num-1]
# return  : 0:success
#           1:failed
################################################################################
function is_integer2
{
	if [ $# -ne 1 ]; then
		install_log DEBUG "COMMONLIB" "Parameters count error, need: str."
		return 1
	fi
	typeset str="$1"

	# max integer: 2147483648
	typeset int_val=`echo "${str}" | awk '{ if($0~/^[0-9]+$/ && $0 >= 0 && $0 < 2147483648) print $0; }'`
	if [ "X${int_val}" = "X" ]; then
		return 1
	fi

	return 0
}

################################################################################
# name    : set_progress_range
# describe: set component install progress range.
# parameter list: 
#           para1: min_rate    [0,100)
#           para2: max_rate    (0,100]
# output  : null
# return  : 0:success
#           1:failed
################################################################################
function set_progress_range
{
	typeset rate_min=`echo "$1" | awk '{ if($0~/^[0-9]+$/ && $0 >= 0 && $0 <= 100) print $0; }'`
	typeset rate_max=`echo "$2" | awk '{ if($0~/^[0-9]+$/ && $0 >= 0 && $0 <= 100) print $0; }'`
	
	if [ "X${rate_min}" = "X" -o "X${rate_max}" = "X" ]; then
		install_log DEBUG LIB "Parameters error, need: [rate_min, rate_max]."
		return 1
	fi
	
	if [ ${rate_min} -gt ${rate_max} ]; then
		install_log DEBUG LIB "Parameters error, [rate_min] should less than [rate_max]."
		return 1
	fi
	
	PROGRESS_MIN=${rate_min}
	PROGRESS_MAX=${rate_max}
	
	return 0
}

################################################################################
# name    : install_progress
# describe: output install progress in ideploy web page.
# parameter list: 
#           para1: rate    range[0,100]
# output  : null
# return  : 0:success
#           1:failed
################################################################################
function install_progress
{
	typeset rate=`echo "$1" | awk '{ if($0~/^[0-9]+$/ && $0 >= 0 && $0 <= 100) print $0; }'`
	if [ "X${rate}" = "X" ]; then
		install_log DEBUG LIB "Parameters error, need [rate]."
		return 1
	fi
	
	if [ ${rate} -eq 0 ]; then
		log_echo rate ${PROGRESS_MIN}
		return 0
	fi
	
	if [ ${rate} -eq 100 ]; then
		log_echo rate ${PROGRESS_MAX}
		return 0
	fi
	
	typeset g_rate=`echo "${rate}" | awk -vmin=${PROGRESS_MIN} -vmax=${PROGRESS_MAX} '{ print min + int((max-min)*($0+1)/100) }'`
	log_echo rate ${g_rate}
	
	return 0
}

################################################################################
# name    : env_init_cmd
# describe: generate a command list to initialize component shell environment.
# parameter list: 
#           shell            shell name and path of component run user.
# output  : shell command list, separate by semicolon
# return  : 0:success
#           1:failed
################################################################################
#function env_init_cmd
#{
#	if [ $# -ne 1 ]; then
#		install_log DEBUG LIB "Generate command list to initialize component shell environment failed."
#		echo "ls"
#		return 1
#	fi
#	typeset comp_dir="$1"
#	touch "${comp_dir}/pub.inc"
#    chmod 777 "${comp_dir}/pub.inc"
#    echo "#!/usr/bin/ksh" > "${comp_dir}/pub.inc"
#    echo "INSTALL_TASK_DIR=\"${INSTALL_TASK_DIR}\" " >> "${comp_dir}/pub.inc"
#    echo "PROGRESS_MIN=${PROGRESS_MIN}" >> "${comp_dir}/pub.inc"
#    echo "PROGRESS_MAX=${PROGRESS_MAX}" >> "${comp_dir}/pub.inc"
#    echo ". ${INSTALL_TASK_DIR}/script/commonlib.inc" >> "${comp_dir}/pub.inc"
#	return 0
#}

################################################################################
# function: run_vcs_cmd
# description:
#     run a vcs command, if the vcs config is not rw, modify it to rw.
# parameters:
#            null
# output:
#            null
# return:
#            0 succeed
#            1 fail
################################################################################
function run_vcs_cmd
{
	if [ $# -ne 1 ]
	then 
		install_log "ERROR" "LIB" "The number of parameters error, it requres only one parameter!"
		return 1
	fi
	
	typeset cmd="${1}"
	typeset flagfile="/etc/VRTSvcs/conf/config/.stale"
	typeset errfile="/tmp/vcs_cmd_$$.tmp"
	if [ ! -f "$flagfile" ];then
    	/opt/VRTSvcs/bin/haconf -makerw 1>"${errfile}" 2>"${errfile}"
		typeset rt=$?
		grep "Cluster already writable" "${errfile}" > /dev/null 2>&1
		typeset isrw=$?
		typeset errInfo=$(cat "${errfile}")
		rm -f "${errfile}"
		if [ ${rt} -ne 0 -a ${isrw} -ne 0 ]
		then
			echo "${errInfo}"|grep "Cluster already writable" 1>/dev/null 2>&1
			if [ $? -ne 0 ]
			then 
				install_log DEBUG LIB "Executing vcs command: haconf -makerw failed, err info: ${errInfo}."
				return 1
			fi
		fi
	fi
	
	typeset idx=0
	while [ ${idx} -lt 10 ]
	do
		((idx=idx+1))
		eval "$cmd"  1>"${errfile}" 2>&1
		typeset rt=$?
		typeset errInfo=$(cat ${errfile})
		rm -f "${errfile}"
		if [ ${rt} -eq 0 ]
		then
			return 0 
		fi 
		
		echo ${errInfo}|grep "must be ReadWrite" 1>/dev/null 2>&1
		if [ $? -ne 0 ]
		then 
			install_log "ERROR" "LIB" "Executing vcs command: ${cmd} failed, error info: ${errInfo}"
			return 1 
		else
			sleep 1
			/opt/VRTSvcs/bin/haconf -makerw 1>"${errfile}" 2>"${errfile}"
			typeset rt=$?
			typeset errInfo=$(cat "${errfile}")
			rm -f "${errfile}"

			if [ ${rt} -ne 0 ]
			then
				echo "${errInfo}"|grep "Cluster already writable" 1>/dev/null 2>&1
				if [ $? -ne 0 ]
				then 
					install_log DEBUG LIB "Executing vcs command: haconf -makerw failed, err info: ${errInfo}."
					return 1
				fi
			fi
		fi
	done 
}

################################################################################
# function name: exec_cmd
# description  : execute specified command, store return code and stdout/stderr.
# note         :
#                (1)not support i/o redirection
#                (2)not support combined command
# parameters   :
#                $* command and parameters
# input        : null
# output       :
#                ERR_CODE	return code of this command
#                ERR_MSG	stdout/stderr of this command
# return       :
#                $? return code of this command
################################################################################
function exec_cmd
{
	install_log DEBUG LIB "Calling function exec_cmd, parameters: [$*]."
	
	# verify params
	typeset cmd=$(echo "$*" | sed -e 's/^[ \t]*//g;s/[ \t]*$//g')
	if [ "x${cmd}" = x ]; then
		ERR_MSG="Command is empty."
		return 1
	fi
	
	# parse cmd and params
	cmd=""
	typeset param_count=$#
	while [ ${param_count} -gt 0 ]
	do
			if [ "x${cmd}" = "x" ]; then
				cmd="$1"
			else
				cmd="${cmd} \"$1\""
			fi
			
			shift
			((param_count=param_count-1))
	done
	
	# execute cmd
	typeset tmpfile="/tmp/exec_cmd_$$.tmp"
	set +x
	eval "${cmd}" > ${tmpfile} 2>&1
	ERR_CODE=$?
	ERR_MSG=$(cat ${tmpfile})
	rm -f ${tmpfile}
	install_log DEBUG LIB "Command return: ${ERR_CODE}, output: [${ERR_MSG}]."
	
	return ${ERR_CODE}
}

################################################################################
# function: check_process
# description:
#     check process
# parameters:
#            1 comp_user_name
# output:
#            null
# return:
#            0 succeed
#            1 fail
################################################################################
function check_process
{
	if [ $# -ne 1 ]
	then 
		install_log "ERROR" "LIB" "The number of parameters error, it requres only one parameter!"
		return 1
	fi
	
	typeset comp_user_name="${1}"
	
	#check process
	typeset check_num=0

	while [ ${check_num} le 2 ]
	do
		typeset is_comp_run=`ps -fu ${comp_user_name} | wc -l | sed 's/[ \t]//g'`
		if [ ${is_comp_run} -ge 2 ]; then
			
			if [ ${check_num} le 2 ]; then
				sleep 2
				((check_num+=1))
				continue
			else
				return 1
			fi
		else
			break
		fi
	done
	
	return 0
	
}

################################################################################
# function: get_nic_name
# description:
#     get NIC name.
# parameters:
#            null 
# output:
#            NIC name
# return:
#            0 succeed
#            1 fail
################################################################################
function get_nic_name
{
	get_localhost_ip
	if [ $? -ne 0 ]
	then
		install_log ERROR LIB "Getting localhost ip failed."
		return 1
	fi
	typeset ip_addr="${RETURN[0]}"
	
	typeset nic_name=""
	
	nic_name=$(ifconfig |awk -vip_str="addr:${ip_addr}" 'BEGIN{str=""}{if($2 == ip_str)exit(0);str=$0;}END{print str;}'| awk '{print $1}'|awk -F: '{print $1}')
	if [ $? -ne 0 ]
	then
		install_log ERROR LIB "Getting the nic name failed."
		return 1
	fi
	
	RETURN[0]="${nic_name}"
	return 0
}
################################################################################
# function: get_net_mask
# description:
#     get_net_mask
# parameters:
#            null
# output:
#            net mask
# return:
#            0 succeed
#            1 fail
################################################################################
function get_net_mask
{
	get_localhost_ip
	if [ $? -ne 0 ]
	then
		install_log ERROR LIB "Getting localhost ip failed."
		return 1
	fi
	typeset ip_addr="${RETURN[0]}"
	
	typeset net_mask=""
	
	net_mask=$(ifconfig |grep -w "addr:${ip_addr}"|awk '{print $4}'|awk -F: '{print $2}')
	if [ $? -ne 0 ]
	then
		install_log ERROR LIB "Getting the net mask failed."
		return 1
	fi
	
	RETURN[0]="${net_mask}"
	return 0
}

################################################################################
# function: rpm_install
# description:
#     install rpm package.
# parameters:
#            rpm package name.
# output:
#
# return:
#            0 succeed
#            1 fail
################################################################################
function rpm_install
{
	if [ $# -ne 1 ]
	then 
		install_log "ERROR" "LIB" "There must be only one  parameter, means rpm name."
		return 1 
	fi
	
	typeset rpm_name="${1}"
	
	typeset rpm_install_log="${TMP}_install_rpm_$$.log"
	typeset rpm_install_info=""
	
	typeset rpm_version=$(echo ${rpm_name}|sed "s/\.rpm$//g")
	
	typeset idx=0
	while [ idx -lt 10 ]
	do
		((idx=idx+1))
		rpm -q ${rpm_version} 1>"${rpm_install_log}" 2>&1
		typeset rt=$?
		rpm_install_info=$(cat ${rpm_install_log})
		rm -f "${rpm_install_log}"
		if [ $rt -eq 0 ]
		then
			install_log INFO LIB "The rpm package \"${rpm_name}\" has been installed."
			return 0
		else 
			install_log INFO LIB "The rpm package \"${rpm_name}\" has not been installed. The debug log is ${rpm_install_info}"
		fi
		
		rpm -Uivh "${rpm_name}" 1>"${rpm_install_log}" 2>&1 
		typeset rt=$?
		typeset rpm_install_info=$(cat ${rpm_install_log})
		rm -f "${rpm_install_log}"
		if [ $rt -ne 0 ];then
			echo "${rpm_install_info}"|grep "already installed" >/dev/null
			if [ $? -eq 0 ];then
				install_log "INFO" LIB "${rpm_name} has already been installed."
				return 0
			fi
			
			echo "${rpm_install_info}"|grep "error: cannot get exclusive lock on /var/lib/rpm/Packages" >/dev/null
			if [ $? -eq 0 ]
			then
				install_log INFO LIB  "Getting the exclusive lock failed, wait 5 seconds and try again."
				sleep 5
				continue
			fi
			
			
			install_log "ERROR" "CHECK_ENV" "install package ${rpm_name} failed, the reason is ${rpm_install_info}."
			return 1
		fi
	done
}
################################################################################
# function: get_name_by_ne
# description:
#     get node name in case of ne name
# parameters:
#            
# output:
#
# return:
#            0 succeed
#            1 fail
################################################################################
function get_name_by_ne
{
    typeset ne_name="$1"
    case ${ne_name} in
	MDMC_ALL|MDMC|MDMC_NO_CMS|MDMC_NO_PMS|MDMC_NO_PMS_CMS)
        RETURN[0]="mdmc_ip"
        RETURN[1]="db_ip"
    ;;
    CONTENTFTP)
        RETURN[0]="cntftp_ip"
        RETURN[1]=""
    ;;   
    APACHE)
        RETURN[0]="apache_ip"
        RETURN[1]=""
    ;;
    ENIP)
        RETURN[0]="enip_ip"
        RETURN[1]=""
    ;;
    EnablerAdpt)
        RETURN[0]="ea_ip"
        RETURN[1]=""
    ;;
    SubqueryAdpt)
        RETURN[0]="sqa_ip"
        RETURN[1]=""
    ;;
    AccessServer)
        RETURN[0]="as_ip"
        RETURN[1]=""
    ;;
    Charging_with_Dccproxy)
        RETURN[0]="cbe_ip"
        RETURN[1]=""
    ;;
    UOA)
        RETURN[0]="uoa_ip"
        RETURN[1]=""
    ;;
    MsgTraceServer)
        RETURN[0]="mts_ip"
        RETURN[1]=""
    ;;
    SmsAdpt)
        RETURN[0]="smsa_ip"
        RETURN[1]=""
    ;;
    BILLCONVERTOR)
        RETURN[0]="bcnvt_ip"
        RETURN[1]=""
    ;;
    *)
        RETURN[0]=""
        RETURN[1]=""
    ;;
	esac
}
################################################################################
# function: modify_tz_env
# description:
#     modify TZ env
# parameters:
#            
# output:
#
# return:
#            0 succeed
#            1 fail
################################################################################
function modify_tz_env
{
    typeset tz_file="/etc/profile.d/profile.csh"
    install_log "INFO" "LIB" "begin to modify TZ in ${tz_file}"
    typeset tz_value=""
    read_value "tz_env_variable"
    if [ $? -ne 0 ];then
        install_log "ERROR" "LIB" "modify_tz_env : read value tz_env_variable failed for modify ${tz_file}"
        return 1 
    fi
    tz_value="${RETURN[0]}"
    grep -v "#" ${tz_file} | grep -w "setenv" | grep -w "TZ" > "${IDEPLOY_NULL}" 2>&1
    if [ $? -ne 0 ];then
        echo "setenv TZ ${tz_value}" >> "${tz_file}"
        return 0 
    fi
    typeset tz_local=$(grep -v "#" ${tz_file} | grep -w "setenv" | grep -w "TZ" | awk '{print $NF}' | sed -n '$p') 
    sed "s#[ \t]*setenv[ \t]*TZ[ \t]*${tz_local}#setenv TZ ${tz_value}#g" "${tz_file}" > "${tz_file}_$$"
    if [ $? -ne 0 ];then
        return 1
    fi
    mv -f "${tz_file}_$$" "${tz_file}"
    install_log "DEBUG" "LIB" "modify_tz_env : modify TZ from ${tz_local} to ${tz_value} in ${tz_file}"
    install_log "INFO" "LIB" "modify TZ in ${tz_file} complete"    
}

################################################################################
# log functions
################################################################################

#ha log file path of AccessServer
HA_LOG_FILE=$(dirname "$0")/log/$(basename "$0" .sh).log
HA_LOG_FILE_DIR=$(dirname ${HA_LOG_FILE})

################################################################################
# name    : witeLog
# describe: write log in ha script.
# paramss:
#			type		DEBUG, INFO, WARN, ERROR
#			log_msg
# output  : null
# rerurn  : 0:success
#           1:failed
# invoker : public
###############################################################################
function writeLog
{
    typeset DATE_STR=`date '+%Y-%m-%d %H:%M:%S'`
    
	#check parameters
    if [ $# -lt 2 ];then
       echo "[${DATE_STR}][ERROR]Failed to call install_log. Parameters number is incorrect."\
        >>"${HA_LOG_FILE}"
       return 1
    fi
	typeset -u log_type="$1"
	shift
	typeset log_msg="$@"

	#initial log file and process backup
    log_file_init2
	
    #process the branch from the type of log
    case ${log_type} in
		DEBUG)
			echo "[${DATE_STR}][DEBUG]${log_msg}" >>"${HA_LOG_FILE}"
	  		;;
	  	INFO) 
			echo "[${DATE_STR}][INFO]${log_msg}"
			echo "[${DATE_STR}][INFO]${log_msg}" >>"${HA_LOG_FILE}"
	  		;; 
	  	WARN)
			echo "[${DATE_STR}][WARN]${log_msg}"
			echo "[${DATE_STR}][WARN]${log_msg}" >>"${HA_LOG_FILE}"
	  		;; 
	  	ERROR)
			echo "[${DATE_STR}][ERROR]${log_msg}"
			echo "[${DATE_STR}][ERROR]${log_msg}" >>"${HA_LOG_FILE}"
	  		;;
	  	*)
			echo "[${DATE_STR}][ERROR]Unknown log type:${log_type}, log message: ${log_msg}"
			echo "[${DATE_STR}][ERROR]Unknown log type:${log_type}, log message: ${log_msg}" >>"${HA_LOG_FILE}"
			return 1
	  		;;
    esac
	
	return 0
}

################################################################################
# name    : log_file_init2
# describe: initialize log file, and process log file backup.
# input   : null
# output  : null
# rerurn  : 0:success
#           1:failed
# invoker : private
################################################################################
function log_file_init2
{
	typeset LOG_FILE_DIR="${HA_LOG_FILE_DIR}"	
	typeset MAX_LOG_FILE_SIZE=10485760
	typeset MAX_LOG_FILE_BACKUP=10
	typeset log_file_name="${HA_LOG_FILE}"
	
	if [ ! -f "${log_file_name}" ]; then		
		if [ ! -d "${LOG_FILE_DIR}" ]; then
			mkdir -p "${LOG_FILE_DIR}" > /dev/null 2>&1
			typeset rt=$?
			chmod 777 "${LOG_FILE_DIR}" > /dev/null 2>&1
			if [ $? -ne 0 -o ${rt} -ne 0 ]; then
				#echo "Creating log dir: ${LOG_FILE_DIR} failed."
				return 1
			fi
		fi
		
		touch "${log_file_name}" > /dev/null 2>&1
		typeset rt=$?
		chmod 777 "${log_file_name}" > /dev/null 2>&1
		if [ $? -ne 0 -o ${rt} -ne 0 ]; then
			#echo "Creating log file: ${log_file_name} failed."
			return 1
		fi
		
		return 0
	fi
	
	typeset file_size=$(wc -c "${log_file_name}" | awk '{ print $1; }')
	if [ ${file_size} -ge ${MAX_LOG_FILE_SIZE} ]; then
		# backup log file name format: ${log_file_name}.yyyymmdd.n
		typeset log_file_base_name=$(basename "${log_file_name}")
		typeset bak_log_file_list=$((cd "${LOG_FILE_DIR}"; ls) | sed -n "/^${log_file_base_name}\.[0-9]\{14\}\.[1-9][0-9]*\$/p" | awk -F. -vmaxnum=${MAX_LOG_FILE_BACKUP} '{ if ($4 <= maxnum ) { print $0; } }' | sort -r -t. -k4 -n)
		if [ "x${bak_log_file_list}" != "x" ]; then
			for logfile in ${bak_log_file_list}
			do
				typeset leadpart=$(echo "${logfile}" | cut -d. -f1-3)
				typeset suffix=$(echo "${logfile}" | cut -d. -f4)
				if [ ${suffix} -eq ${MAX_LOG_FILE_BACKUP} ]; then
					rm -f "${LOG_FILE_DIR}/${logfile}"
					continue
				fi
				
				((suffix=suffix+1))
				(cd "${LOG_FILE_DIR}"; mv -f "${logfile}" "${leadpart}.${suffix}")
			done
		fi
		
		mv -f "${log_file_name}" "${log_file_name}.$(date +'%Y%m%d%H%M%S').1"
		
		# recreate a log file
		touch "${log_file_name}" > /dev/null 2>&1
		typeset rt=$?
		chmod 777 "${log_file_name}" > /dev/null 2>&1
		if [ $? -ne 0 -o ${rt} -ne 0 ]; then
			#echo "Creating log file: ${log_file_name} failed."
			return 1
		fi
		
		return 0
	fi
	
	return 0
}

################################################################################
# Function    : run_sql
# Description : execute sql script to specify db server
# parameter list:
#                $1	the name of sql script
#				 $2 operate type : backup update rollback
#				 $3 login user name
#				 $4 the password of login user
#				 $5 the server url
#				 $6 the comp name
# Output      : None
# Return      : 1 failed
#               0 success
################################################################################
function run_sql
{	
	if [ $# -ne 6 ]
	then
		install_log ERROR "database" "the number of input parameter is incorrect!"
		return 1
	fi
	
	typeset sql_name="$1"
	typeset operFlag="$2"
	typeset user_name="$3"
	typeset user_passwd="$4"
	typeset log_prefix="${operFlag}-function run_sql::"	
	typeset server_url="$5"
    typeset comp_name="$6"
	if [ "x${sql_name}" = "x" ]
	then
		install_log ERROR "${comp_name}" "the sql_name is null string!"
		return 1
	fi
	
	if [ "x${operFlag}" = "x" ]
	then
		install_log ERROR "${comp_name}" "the operation type is null string!"
		return 1
	fi
	
	if [ "x${user_name}" = "x" ]
	then
		install_log ERROR "${comp_name}" "the user_name is null string!"
		return 1
	fi
	
	if [ "x${user_passwd}" = "x" ]
	then
		install_log ERROR "${comp_name}" "the user_passwd is null string!"
		return 1
	fi
	
	install_log INFO "${comp_name}" "start to execute ${sql_name}"
	
	typeset work_base_dir="$HOME/patches/${pkg_name}/${dbType}"
	if [ -f ${work_base_dir}/${operFlag} ];then
		rm -rf ${work_base_dir}/${operFlag}
	fi
	
	mkdir -p ${work_base_dir}/${operFlag}
	if [ $? -ne 0 ];then
		install_log ERROR "${comp_name}" "create ${operFlag} failed"
	fi

	chmod 777 ${work_base_dir}/${operFlag}
	
	#the vakue of sql_prefix is such as aaa.sql
    typeset sql_prefix=$(basename "${sql_name}")
    #the vakue of sql_prefix is such as aaa
	sql_prefix=$(echo ${sql_prefix} |  tr -s . " " |awk '{print $1}')
    #create log file
	typeset sqltmp_log="${work_base_dir}/${operFlag}/${sql_prefix}.log"
	echo "" > ${sqltmp_log}
	
	if [ ! -f ${sql_name} ]; then
		install_log ERROR "${comp_name}" "${log_prefix} the file ${sql_name} is not exist."
		return 1
	fi
	#the file check_orauser.log is in the dir of such path /opt/oracle/patches/db_patch_20110708_1
    typeset check_orauser_file="check_orauser.log"
	echo "">${check_orauser_file}
	
    sqlplus ${user_name}/${user_passwd}@${server_url} <<EOF 1>>${check_orauser_file} 2>&1
	exit;
	/
EOF
	
	typeset error=$(egrep "(ERROR|ORA-|Usage)" ${check_orauser_file})
	if [ "x${error}" != "x" ];then
		install_log ERROR "check" "some error occured when execute command: sqlplus ${user_name}/${user_passwd}@${server_url},please check it manually."
		return 1
	fi
    
    #execute sql script here
sqlplus ${user_name}/${user_passwd}@${server_url} <<EOF 1>>${sqltmp_log} 2>&1
     @${sql_name}
    exit;
    /
EOF
	
	typeset error=`${GREP} "ERROR" ${sqltmp_log}` 
	if [ "x${error}" != "x" ]; then
		install_log ERROR "${comp_name}" "the sql file ${sql_name} execute failed.more detail please to see ${sqltmp_log}"
		return 1
	fi
	install_log INFO "${comp_name}" "end of execute ${sql_name}"	
}

################################################################################
# Function    : db_cut_version_noneed_update
# Description : cut version no need to update for db
# parameter list:null
# Output      : None
# Return      : 1 failed
#               0 success
################################################################################
function db_cut_version_noneed_update
{   
    typeset mdsp_version_file="${UPDATE_TASK_DIR}/script/mdsp_version.ini"
    
    if [ ! -f ${mdsp_version_file} ];then
        return 0
    fi
    
    install_log DEBUG "${comp_name}" "==========begin to cut some no need update sql in pkg ${pkg_name}=========="
    
    #such as MDSP,CBE,BME,PMP,CPM
    #typeset update_module_List=$(cat ${mdsp_version_file}|grep -v "\[.*\]"|grep -v "^#"|sed '/^[ /t]*$/d'|awk -F= '{print $1}')
    #the value of db_update_List such as sysdb,cbedb,userdb
    #the value of comp_name such as db0,db1
    typeset db_update_List=$(cat ${update_file} | grep "^${comp_name}" | awk -F= '{print $1}' | awk -F. '{print $2}' | grep -v "server")
    typeset all_conf_files="backup-sql.conf update-sql.conf rollback-sql.conf"
    for db_Type in ${db_update_List}
    do
        for conf_file in ${all_conf_files}
        do
            if [ ! -f $HOME/patches/${pkg_name}/${db_Type}/${conf_file} ];then
                continue
            fi
            
            typeset update_sql_List=$(cat $HOME/patches/${pkg_name}/${db_Type}/${conf_file} | tr -d '\r' | grep -v "^#")
            
            if [ "x${update_sql_List}" == "x" ];then
                continue
            fi
            
            echo "${update_sql_List}" | sed -n '1p' | grep "/" >/dev/null 2>&1
            if [ $? -ne 0 ];then
                install_log DEBUG "${comp_name}" "the pacth update pkg used the old templdate."
            else
                typeset ver_order_character=$(echo "${update_sql_List}"|sed -n '1p'|awk -F'/' '{print $1}'|sed 's/\(^.*R[0-9]\{3\}\).*$/\1/')
                
                typeset site_version_tmp=$(cat ${mdsp_version_file} | grep -v "^#" | awk -F'=' -vver_order_c="${ver_order_character}" 'BEGIN{
                    ptn = "^[ \t]*" ver_order_c;  
                }
                {
                    if ($2 ~ ptn)
                    {
                        print $2;
                        exit(0);
                    }
                }')
                #trim the blank of begin and end
                typeset site_version=$(echo ${site_version_tmp})
                
                if [ "x${site_version}" == "x" ];then
                    install_log ERROR "${comp_name}" "the version info you configured in $HOME/patches/${pkg_name}/${db_Type}/${conf_file} is error, please check the validation of it."
                    return 1
                else
                    install_log DEBUG "${comp_name}" "site_version=${site_version}."
                    typeset updatepkg_all_version=$(cat $HOME/patches/${pkg_name}/${db_Type}/${conf_file}| tr -d '\r' | grep -v "^#" | awk -F'/' '{print $1}'| sort -u)
                        
                    typeset noneed_update_version=""
                    #compare version string
                    for tmp_version in ${updatepkg_all_version}
                    do
                        if [[ "${tmp_version}B999" < "${site_version}B999" || "${tmp_version}B999" == "${site_version}B999" ]];then
                            noneed_update_version=${noneed_update_version}" "${tmp_version}
                            #install_log INFO "${comp_name}" "the sql script in version ${tmp_version} no need to update."
                        fi
                    done
                                
                    if [ "x${noneed_update_version}" == "x" ];then
                        continue
                    fi
                    install_log DEBUG "${comp_name}" "the version as follows: ${noneed_update_version} no need to update."
                            
                    if [ ! -f "$HOME/patches/${pkg_name}/${db_Type}/${conf_file}.bak" ];then
                        cp "$HOME/patches/${pkg_name}/${db_Type}/${conf_file}" "$HOME/patches/${pkg_name}/${db_Type}/${conf_file}.bak"
                        if [ $? -ne 0 ];then
                            install_log ERROR "${comp_name}" "backup file:  $HOME/patches/${pkg_name}/${db_Type}/${conf_file} failed."
                            return 1
                        fi
                    fi
                    
                    for tmp_noneed_version in ${noneed_update_version}
                    do
                        sed -i "/${tmp_noneed_version}/d" $HOME/patches/${pkg_name}/${db_Type}/${conf_file}
                        if [ $? -ne 0 ];then
                            install_log ERROR "${comp_name}" "delete some sql script of version ${tmp_noneed_version} failed, which configured in $HOME/patches/${pkg_name}/${db_Type}/${conf_file} but no need to update."
                            return 1
                        #else
                        #    install_log DEBUG "${comp_name}" "delete some sql script of version ${tmp_noneed_version} succeed, which configured in $HOME/patches/${pkg_name}/${db_Type}/${conf_file} but no need to update."
                        fi
                    done     
                fi   
            fi   
        done            
    done
    install_log DEBUG "${comp_name}" "=========================================end========================================"
    
    return 0
}

################################################################################
# Function    : app_cut_version_noneed_update
# Description : cut version no need to update for application
# parameter list:null
# Output      : None
# Return      : 1 failed
#               0 success
################################################################################
function app_cut_version_noneed_update
{
    typeset version_order_cfg="${PATCH_DIR}/custom/version_order.cfg"

    if [ ! -f ${version_order_cfg} ];then
        return 0
    fi
    
    install_log DEBUG "${comp_name}" "==========begin to cut some no need update version in pkg ${pkg_name}=========="
    
    dos2unix -n "${version_order_cfg}" "${version_order_cfg}_$$" >/dev/null 2>&1
    cp "${version_order_cfg}_$$" "${version_order_cfg}"
    rm "${version_order_cfg}_$$"
    #typeset version_list=$(cat ${version_order_cfg} | tr -d '\r' | sed '/^[ /t]*$/d')
        
    typeset updatepkg_all_version=$(cat ${version_order_cfg} | grep -v "^#" | tr -d '\r' | sed '/^[ /t]*$/d')

    if [ "x${updatepkg_all_version}" != "x" ];then
        #get the update module such as MDSP,CBE,PMP,BME
        #typeset update_module=$(echo ${updatepkg_all_version} | awk '{print $1}' | awk -F'_' '{print $1}')
        
        #take care: the difference of next line, the result of this command is not we expected.
        #typeset ver_order_character=$(echo ${updatepkg_all_version} | sed -n '1p'|sed 's/\(^.*R[0-9]\{3\}\).*$/\1/')
        
        typeset ver_order_character_tmp=$(echo "${updatepkg_all_version}" | sed -n '1p'|sed 's/\(^.*R[0-9]\{3\}\).*$/\1/')
        
        #trim the blank of begin and end
        typeset ver_order_character=$(echo ${ver_order_character_tmp})
        #the value of site_version is like MDSP_V500R002C26
            
        #tr a-z A-Z <a >b
        #tr [:upper:] [:lower:] < a
        #typeset -u site_version=""
        typeset site_version=""
            
        typeset mdsp_version_file="${UPDATE_TASK_DIR}/script/mdsp_version.ini"
        #update patch update pkg by ideploy
        if [ -f ${mdsp_version_file} ];then
            typeset tmp_site_version=$(cat ${mdsp_version_file} | grep -v "^#" | awk -F'=' -vver_order_c="${ver_order_character}" 'BEGIN{
                ptn = "^[ \t]*" ver_order_c;  
            }
            {
                if ($2 ~ ptn)
                {
                    print $2;
                    exit(0);
                }
            }')
            
            site_version=$(echo ${tmp_site_version})
            
            if [ "x${site_version}" == "x" ];then
                install_log ERROR "${comp_name}" "the version info of ${comp_name} you configured in ${version_order_cfg} may be not correct."
                return 1
            fi
            install_log DEBUG "${comp_name}" "site_version=${site_version}."
            
            #typeset update_module_List=$(cat ${mdsp_version_file}|grep -v "\[.*\]"|grep -v "^#"|sed '/^[ /t]*$/d'|awk -F= '{print $1}')
            #echo "${update_module_List}"|grep -w "${update_module}" > /dev/null 2>&1
            #if [ $? -ne 0 ];then
            #    install_log ERROR "${comp_name}" "the version info of ${comp_name} you configured in ${version_order_cfg} may be not correct."
            #    return 1
            #else
            #    site_version=$(cat ${mdsp_version_file} | grep -v "^#" | grep "${update_module}=" | awk -F= '{print $2}')
            #fi
            
        #update one small patch update pkg by manually
        else
            while [ true ]
            do
                echo "please input the version of current site with Capital Character, such as MDSP_V500R002C08:"
                echo "*************************"
                read version_number
                #echo "${updatepkg_all_version}" | grep -iw "${version_number}" > /dev/null 2>&1
                #if [ $? -eq 0 ];then
                #    site_version="${version_number}"
                #    break
                #else
                    echo "The version of current site you put is [${version_number}]. are you sure[y/n]?"
                    read yes_or_no
                    if [ "x${yes_or_no}" == "xy" -o "x${yes_or_no}" == "xY" -o "x${yes_or_no}" == "xyes" -o "x${yes_or_no}" == "xYES" ];then
                        site_version="${version_number}"
                        break
                    else
                        echo "********try again********"
                    fi
                #fi
            done
        fi
            
        typeset noneed_update_version=""
        #compare version string
        for tmp_version in ${updatepkg_all_version}
        do
            if [[ "${tmp_version}B999" < "${site_version}B999" || "${tmp_version}B999" == "${site_version}B999" ]];then
                noneed_update_version=${noneed_update_version}" "${tmp_version}
                #install_log INFO "${comp_name}" "the custom update script in version ${tmp_version} no need to update."
            fi
        done
            
        if [ "x${noneed_update_version}" != "x" ];then
            install_log DEBUG "${comp_name}" "the version as follows: ${noneed_update_version} no need to update."
            
            if [ ! -f "${version_order_cfg}.bak" ];then
                cp "${version_order_cfg}" "${version_order_cfg}.bak"
                if [ $? -ne 0 ];then
                    install_log ERROR "${comp_name}" "backup file: ${version_order_cfg} failed."
                    return 1
                fi
            fi
                                    
            for tmp_noneed_version in ${noneed_update_version}
            do
                sed -i "/${tmp_noneed_version}/d" ${version_order_cfg}
                if [ $? -ne 0 ];then
                    install_log ERROR "${comp_name}" "delete the version of ${tmp_noneed_version} failed which configured in ${version_order_cfg} but no need to update."
                    return 1
                #else
                #    install_log DEBUG "${comp_name}" "delete the version of ${tmp_noneed_version}  succeed which configured in ${version_order_cfg} but no need to update."
                fi
            done    
        fi
            
    else
        #need to confirm
        install_log ERROR "${comp_name}" "the content of ${version_order_cfg} is empty."
        return 1
    fi
    
    install_log DEBUG "${comp_name}" "=========================================end========================================"
    
    return 0
}

################################################################################
# Function    : backup_files_from_cfg
# Description : backup files from backup_files.cfg of all version
# parameter list:null
# Output      : None
# Return      : 1 failed, 2 do nothing
#               0 success
################################################################################
function backup_files_from_cfg
{
    typeset version_order_cfg="${PATCH_DIR}/custom/version_order.cfg"
    
    if [ ! -f ${version_order_cfg} ];then
        return 2
    fi
        
    typeset all_update_version=$(cat ${version_order_cfg} | grep -v "^#" | tr -d '\r' | sed '/^[ /t]*$/d')
        
    if [ "x${all_update_version}" != "x" ];then
        typeset all_backup_files="${PATCH_DIR}/custom/all_backup_files_$$"
        if [ -f ${all_backup_files} ];then
            rm -f ${all_backup_files}
        fi
            
        for tmp_version in ${all_update_version}
        do
            if [ -f ${PATCH_DIR}/custom/${tmp_version}/backup_files.cfg ];then
                cat ${PATCH_DIR}/custom/${tmp_version}/backup_files.cfg >> ${all_backup_files}
            else
                install_log WARN "${comp_name}" "can not find the backup configure file backup_files.cfg in directory: ${PATCH_DIR}/custom/${tmp_version}."
            fi
        done
            
        #use sort -u to trim the repeat backup files
        typeset back_files_list=$(cat ${all_backup_files} | tr -d '\r' | sed '/^[ /t]*$/d' | sort -u)
        if [ "x${back_files_list}" != "x" ];then
            #save all need backup files in all_backup_files.cfg
            cat ${all_backup_files}|sort -u > ${PATCH_DIR}/custom/all_backup_files.cfg
            if [ $? -eq 0 ];then
                install_log DEBUG "${comp_name}" "generate ${PATCH_DIR}/custom/all_backup_files.cfg succeed."
            fi
            rm -f ${all_backup_files}
                
            RETURN[0]="${back_files_list}"
            return 0
        else
            install_log DEBUG "${comp_name}" "no files need to backup."
        fi
        rm -f ${all_backup_files}
            
    else
        #need to confirm
        install_log ERROR "${comp_name}" "the content of ${version_order_cfg} is empty."
        return 1
    fi
    
    return 2
}

################################################################################
# Function    : execute_custom_update_script
# Description : execute custom update script
# parameter list:$@
# Output      : None
# Return      : 1 failed
#               0 success
################################################################################
function execute_custom_update_script
{
    typeset all_params="$@"
    
    typeset version_order_cfg="${PATCH_DIR}/custom/version_order.cfg"
    if [ ! -f ${version_order_cfg} ];then
        return 0
    fi
    
    typeset all_update_version=$(cat ${version_order_cfg} | grep -v "^#" | tr -d '\r' | sed '/^[ /t]*$/d')
    if [ "x${all_update_version}" != "x" ];then
        for tmp_version in ${all_update_version}
        do
            if [ -f ${PATCH_DIR}/custom/${tmp_version}/custom_update_script.sh ];then
                #the custom update script must have return value: 0 or 1
                #if custom update script need some param, please add it here.
                #such as : ${PATCH_DIR}/custom/${tmp_version}/custom_update_script.sh "${UPDATE_TASK_DIR}"
                if [ "x${all_params}" == "x" ];then
                    ${PATCH_DIR}/custom/${tmp_version}/custom_update_script.sh
                else
                    ${PATCH_DIR}/custom/${tmp_version}/custom_update_script.sh "$@"
                fi
                    
                if [ $? -ne 0 ];then
                    install_log ERROR "${comp_name}" "execute script ${PATCH_DIR}/custom/${tmp_version}/custom_update_script.sh failed."
                    return 1
                fi    
            else
                install_log WARN "${comp_name}" "can not find custom update script: ${PATCH_DIR}/custom/${tmp_version}/custom_update_script.sh in the version of ${tmp_version}."
            fi
        done
    else
        #need to confirm
        install_log ERROR "${comp_name}" "the content of ${version_order_cfg} is empty."
        return 1
    fi
    
    return 0
}

################################################################################
# Function    : execute_custom_rollback_script
# Description : execute custom rollback script
# parameter list:$@
# Output      : None
# Return      : 1 failed
#               0 success
################################################################################
function execute_custom_rollback_script
{
    typeset all_params="$@"
    
    typeset version_order_cfg="${PATCH_DIR}/custom/version_order.cfg"
    if [ ! -f ${version_order_cfg} ];then
        return 0
    fi
    #use sort -r to rollback custom script from target version to base version 
    #typeset all_update_version=$(cat ${version_order_cfg} | grep -v "^#" | tr -d '\r' | sed '/^[ /t]*$/d' | sort -r)
    typeset all_update_version=$(cat ${version_order_cfg} | grep -v "^#" | tr -d '\r' | sed '/^[ /t]*$/d')
        
    if [ "x${all_update_version}" != "x" ];then
        typeset total_num=$(echo "${all_update_version}"|wc -l)
        
        install_log DEBUG "${comp_name}" "total_num=${total_num}"
        
        typeset tmp_version=""
        #install_log DEBUG "${comp_name}" "the version of rollback sequence is ${all_update_version}."
            
        while [ ${total_num} -gt 0 ]
        do
            tmp_version=$(echo "${all_update_version}" | sed -n "${total_num}p")
            
            install_log DEBUG "${comp_name}" "tmp_version[${total_num}]=${tmp_version}"
            
            if [ -f ${PATCH_DIR}/custom/${tmp_version}/custom_rollback_script.sh ];then
                #the custom rollback script must have return value: 0 or 1
                if [ "x${all_params}" == "x" ];then
                    ${PATCH_DIR}/custom/${tmp_version}/custom_rollback_script.sh
                else
                    ${PATCH_DIR}/custom/${tmp_version}/custom_rollback_script.sh "$@"
                fi
                    
                if [ $? -ne 0 ];then
                    install_log ERROR "${comp_name}" "execute script ${PATCH_DIR}/custom/${tmp_version}/custom_rollback_script.sh failed."
                    return 1
                fi    
            else
                install_log WARN "${comp_name}" "can not find custom update script: ${PATCH_DIR}/custom/${tmp_version}/custom_rollback_script.sh in the version of ${tmp_version}."
            fi
                
            ((total_num=total_num-1))
        done    
    else
        install_log ERROR "${comp_name}" "the content of ${version_order_cfg} is empty."
        return 1
    fi
    
    return 0
}
